user www-data;
worker_processes auto; # Automatically set based on CPU cores
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 1024; // Kept higher, adjust if 768 from expanded is preferred
}

rtmp_socket_dir /var/sock; // From existing nginx.conf, expanded-nginx.conf also uses this

rtmp {
    server {
        listen 1935;
        chunk_size 4096;

        # Access control from expanded-nginx.conf (allows local and 192.168.0.0/24)
        allow publish 127.0.0.1;
        allow publish ::1; # Added for IPv6 localhost consistency
        allow publish 192.168.0.0/24;
        deny publish all;

        allow play 127.0.0.1;
        allow play ::1; # Added for IPv6 localhost consistency
        allow play 192.168.0.0/24;
        deny play all;

        #----------------------------------------------------------------------
        # Transcoding Application (from expanded-nginx.conf XX_TC)
        #----------------------------------------------------------------------
        # Input: rtmp://localhost/XX_TC/YOUR_INPUT_STREAM
        # Output: Pushes transcoded stream to rtmp://localhost/MainStream/YOUR_INPUT_STREAM
        # The master.env variable for this app name is APP_TRANSCODE
        application XX_TC { # Name from expanded-nginx.conf, can be changed via master.env's APP_TRANSCODE
            live on;
            record off;
            # Transcodes and pushes to the MainStream application.
            # Customize ffmpeg parameters as needed.
            # The stream name ($name) is preserved.
            exec ffmpeg -i rtmp://localhost:1935/XX_TC/$name -c:v libx264 -b:v 3128k -minrate 1M -maxrate 6M -bufsize 3128k -bf 2 -r 30 -c:a aac -ar 44100 -ac 1 -f flv rtmp://localhost:1935/MainStream/$name;
        }

        #----------------------------------------------------------------------
        # Main Streaming Application (consolidating features from XX in expanded-nginx.conf and existing apps)
        #----------------------------------------------------------------------
        # Input: rtmp://localhost/MainStream/YOUR_INPUT_STREAM (e.g., from XX_TC or direct ffmpeg push)
        # This application handles:
        # 1. Primary HLS generation.
        # 2. Pushing to individual platforms (Twitch, YouTube, Kick via Stunnel).
        # 3. Generating specific HLS "Shorts" versions using ffmpeg exec.
        # The master.env variable for this app name is APP_MAIN_STREAM
        application MainStream { # Renamed from XX for clarity, configurable via APP_MAIN_STREAM
            live on;
            record off;

            # Primary HLS output (e.g., for main feed)
            hls on;
            hls_path /mnt/hls/1; # From expanded-nginx.conf, ensure HLS_BASE_DIR in master.env is /mnt/hls
            hls_fragment 3s;
            hls_playlist_length 60s; # From expanded-nginx.conf
            hls_nested on; # Creates /mnt/hls/1/STREAM_NAME/index.m3u8

            # --- Platform Pushes (placeholders for keys, to be set in real.env/nginx.conf) ---
            # These should be uncommented and keys inserted in your real.env/nginx.conf,
            # or use exec_push with environment variables if Nginx supports it.

            # Twitch Push (Direct RTMP)
            # The key is part of the URL. $name is the incoming stream name.
            # push rtmp://YOUR_TWITCH_INGEST_SERVER/app/YOUR_TWITCH_STREAM_KEY;
            # Example using a variable that would be substituted by a script:
            # push rtmp://live-lhr08.twitch.tv/app/$XX_TW_KEY; # Assumes $XX_TW_KEY is available or substituted

            # YouTube Push (via Stunnel port 19351)
            # push rtmp://127.0.0.1:19351/live2/YOUR_YOUTUBE_STREAM_KEY;
            # Example using a variable:
            # push rtmp://127.0.0.1:19351/live2/$XX_YT_KEY;

            # Kick Push (via Stunnel port 19352)
            # push rtmp://127.0.0.1:19352/app/YOUR_KICK_STREAM_KEY;
            # Example using a variable:
            # push rtmp://127.0.0.1:19352/app/$XX_KI_KEY;

            # --- Specialized HLS Generation using exec ffmpeg (from expanded-nginx.conf) ---
            # These commands run ffmpeg to create different HLS versions from the input stream.
            # The input is rtmp://localhost:1935/MainStream/$name

            # Shorts Overview HLS (e.g., full frame scaled)
            # Output: /mnt/hls/shorts_1/$name/index.m3u8
            exec ffmpeg -i rtmp://localhost:1935/MainStream/$name -vf "scale=720:-2" -start_at_zero -f hls -hls_time 10 -hls_list_size 6 -hls_flags single_file -hls_segment_filename /mnt/hls/shorts_1/$name/%03d.ts /mnt/hls/shorts_1/$name/index.m3u8;

            # Shorts Zoomed HLS (e.g., cropped and scaled)
            # Output: /mnt/hls/shorts_2/$name/index.m3u8
            exec ffmpeg -i rtmp://localhost:1935/MainStream/$name -vf "crop=360:438:356:250,scale=720:-1" -start_at_zero -f hls -hls_time 10 -hls_list_size 6 -hls_flags single_file -hls_segment_filename /mnt/hls/shorts_2/$name/%03d.ts /mnt/hls/shorts_2/$name/index.m3u8;

            # Optional: Push to ShortsCombined application if further processing/combining of HLS is needed
            # This assumes shorts_1 and shorts_2 are generated and available for ShortsCombined to use.
            # The $name variable ensures that if multiple streams hit MainStream, they are kept separate.
            # push rtmp://localhost:1935/ShortsCombined/$name;
        }

        #----------------------------------------------------------------------
        # Shorts Combined HLS Application (from expanded-nginx.conf XX_combined)
        #----------------------------------------------------------------------
        # Input: This app is designed to be triggered by an incoming stream, but its main
        #        purpose in expanded-nginx.conf was to combine HLS playlists that were
        #        already generated by the 'XX' (now 'MainStream') application.
        #        The exec commands below directly reference those HLS playlists.
        #        If you send a stream here, e.g., rtmp://localhost/ShortsCombined/mystream,
        #        the $name variable will be 'mystream'.
        # The master.env variable for this app name is APP_SHORTS_COMBINED
        application ShortsCombined { # Name from master.env, was XX_combined
            live on;
            record off;

            # HLS output for the combined stream
            hls on;
            hls_path /mnt/hls/shorts; # From expanded-nginx.conf
            hls_fragment 3s;
            hls_playlist_length 60s;
            hls_nested on; # Creates /mnt/hls/shorts/STREAM_NAME/index.m3u8

            # --- FFmpeg for Combining HLS and Pushing (from expanded-nginx.conf) ---
            # These commands assume HLS streams exist at /mnt/hls/shorts_1/$name/index.m3u8
            # and /mnt/hls/shorts_2/$name/index.m3u8, where $name is the incoming stream name
            # to THIS ShortsCombined application.
            # If MainStream is already creating these with $name from its input, ensure consistency.
            # For simplicity, the example below assumes a fixed input name like 'mainstream_output'
            # for the source HLS playlists if $name is not appropriate.
            # You might need to adjust $name or hardcode paths if the stream names differ.

            # Example: Combine HLS playlists (e.g., shorts_1 and shorts_2 for 'main_output' stream)
            # This creates a new HLS stream at /mnt/hls/shorts/$name/index.m3u8
            # Note: Combining HLS playlists with ffmpeg `exec` triggered by an RTMP stream can be complex.
            # The original `expanded-nginx.conf` implies these `exec` commands run when a stream hits `XX_combined`.
            # The input HLS paths might need to be adjusted based on the actual stream name ($name)
            # received by this 'ShortsCombined' application.
            # If MainStream creates /mnt/hls/shorts_1/input_stream_name/index.m3u8, then $name here should match 'input_stream_name'.

            # exec ffmpeg -i /mnt/hls/shorts_1/$name/index.m3u8 -i /mnt/hls/shorts_2/$name/index.m3u8 \\
            #    -filter_complex "[0:v][1:v]vstack=inputs=2[v];[0:a][1:a]amerge=inputs=2[a]" \\
            #    -map "[v]" -map "[a]" -ac 2 -c:v libx264 -preset veryfast -b:v 2500k -bufsize 6000k \\
            #    -pix_fmt yuv420p -flags -global_header -bf 2 -g 60 -keyint_min 60 -vsync cfr -c:a aac -ar 44100 -threads 6 \\
            #    -f hls -hls_time 10 -hls_list_size 6 -hls_flags single_file -hls_segment_filename /mnt/hls/shorts/$name/%03d.ts /mnt/hls/shorts/$name/index.m3u8;

            # Push Combined HLS to YouTube (e.g., for vertical "Shorts" format)
            # This command takes the HLS playlist generated above (or a specific one) and pushes it.
            # Replace YOUR_YOUTUBE_SHORTS_STREAM_KEY_HERE with the key from master.env ($XX_SHORTS_YT_KEY)
            # This also assumes the HLS to push is at /mnt/hls/shorts/$name/index.m3u8.
            # exec ffmpeg -re -i /mnt/hls/shorts/$name/index.m3u8 -c:v libx264 -preset veryfast \\
            #    -b:v 2500k -bufsize 6000k -pix_fmt yuv420p -flags -global_header -bf 2 -g 60 -keyint_min 60 -vsync cfr \\
            #    -c:a aac -ar 44100 -threads 6 -f flv rtmp://a.rtmp.youtube.com/live2/YOUR_YOUTUBE_SHORTS_STREAM_KEY_HERE;
            # Example using a variable (requires Nginx Perl module or similar for env var access, or script substitution):
            # exec ffmpeg -re -i /mnt/hls/shorts/$name/index.m3u8 -c:v libx264 -preset veryfast \\
            #    -b:v 2500k -bufsize 6000k -pix_fmt yuv420p -flags -global_header -bf 2 -g 60 -keyint_min 60 -vsync cfr \\
            #    -c:a aac -ar 44100 -threads 6 -f flv rtmp://a.rtmp.youtube.com/live2/$XX_SHORTS_YT_KEY;
        }

        #----------------------------------------------------------------------
        # Camera Input Application (existing, but HLS path updated)
        #----------------------------------------------------------------------
        # Example: gphoto2 | ffmpeg -i - ... -f flv rtmp://localhost/Cam1/my_camera
        # The master.env variable for this app name is APP_CAM1
        application Cam1 { # Name from master.env
            live on;
            record off;

            # Option 1: Push to the MainStream application (recommended for transcoding/multi-platform)
            push rtmp://127.0.0.1:1935/MainStream/cam1_input; # Pushes to MainStream

            # Option 2: Direct HLS output from Cam1 (if no further processing needed)
            # hls on;
            # hls_path /mnt/hls/CAM1; # Path from expanded-nginx.conf
            # hls_fragment 3s;
            # hls_playlist_length 60s;
            # hls_nested on;
            # exec_push ffmpeg -i rtmp://localhost:1935/Cam1/$name -start_at_zero -f hls -hls_time 10 -hls_list_size 6 -hls_flags single_file -hls_segment_filename /mnt/hls/CAM1/$name/%03d.ts /mnt/hls/CAM1/$name/index.m3u8;
        }

        #----------------------------------------------------------------------
        # Legacy HLS Application (hls_app from original example)
        #----------------------------------------------------------------------
        # This can be kept for compatibility or specific use cases if needed.
        # Streams sent to rtmp://localhost/hls_app/STREAM_NAME will be converted to HLS.
        # HLS output will be at http://YOUR_SERVER_IP_OR_DOMAIN:PORT/hls_generic/STREAM_NAME/index.m3u8
        # The master.env variable for this app name is APP_HLS
        application hls_app { # Name from master.env
            live on;
            record off;
            hls on;
            hls_path /mnt/hls/generic_hls; # Using /mnt/hls base, new subfolder
            hls_fragment 3s;
            hls_playlist_length 30s;
            hls_nested on;
        }


        #----------------------------------------------------------------------
        # Platform Specific Applications (Simplified - MainStream now handles pushes)
        #----------------------------------------------------------------------
        # These applications can be used if you want to send a stream *only* to one platform
        # without going through MainStream, or if MainStream pushes to these, and *these*
        # contain the final push URL with the key.
        # The master.env variables for these are APP_TW, APP_YT, APP_KI.

        application XX_TW { # Twitch - Name from master.env (APP_TW)
            live on; record off;
            # Example: push rtmp://live-lhr08.twitch.tv/app/YOUR_TWITCH_KEY_FROM_REAL_ENV;
        }
        application XX_YT { # YouTube - Name from master.env (APP_YT)
            live on; record off;
            # Example: push rtmp://127.0.0.1:19351/live2/YOUR_YOUTUBE_KEY_FROM_REAL_ENV;
        }
        application XX_KI { # Kick - Name from master.env (APP_KI)
            live on; record off;
            # Example: push rtmp://127.0.0.1:19352/app/YOUR_KICK_KEY_FROM_REAL_ENV;
        }

        #----------------------------------------------------------------------
        # Combined "Push to All" Application (Simplified - MainStream now handles pushes)
        #----------------------------------------------------------------------
        # This application can be a simple relay to MainStream if you want a single
        # ingest point that then gets processed by MainStream.
        # Or, if MainStream pushes to XX_TW, XX_YT, XX_KI, and those apps have the keys,
        # then this app could push to those.
        # The master.env variable for this app name is APP_ALL.
        application XX-All { # Name from master.env (APP_ALL)
            live on;
            record off;
            # Option A: Push input directly to MainStream for full processing
            push rtmp://127.0.0.1:1935/MainStream/$name;

            # Option B: If XX_TW, XX_YT, XX_KI are configured with keys and MainStream is not pushing directly
            # push rtmp://127.0.0.1:1935/XX_TW/$name;
            # push rtmp://127.0.0.1:1935/XX_YT/$name;
            # push rtmp://127.0.0.1:1935/XX_KI/$name;
        }
    }
}

#------------------------------------------------------------------------------
# HTTP Server Block (Updated from expanded-nginx.conf and existing)
#------------------------------------------------------------------------------
http {
    sendfile on;
    tcp_nopush on; # From expanded-nginx.conf
    types_hash_max_size 2048; # From expanded-nginx.conf
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # SSL settings from expanded-nginx.conf (can be customized)
    # ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Consider TLSv1.2 and TLSv1.3 only for better security
    # ssl_prefer_server_ciphers on;

    # Logging from expanded-nginx.conf
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
    gzip on; # From expanded-nginx.conf

    # Includes from expanded-nginx.conf (usually for modular configs)
    # include /etc/nginx/conf.d/*.conf;
    # include /etc/nginx/sites-enabled/*; # Often, the main nginx.conf IS the site.

    keepalive_timeout  65;

    server {
        # Listen on port from master.env (NGINX_HTTP_PORT), default 8080 from expanded-nginx.conf
        # This will be substituted by your setup script if it reads master.env
        listen 8080; # Placeholder, real value from $NGINX_HTTP_PORT
        # server_name yourdomain.com www.yourdomain.com;

        # Default web root (e.g., for status page or general files)
        location / {
            root /var/www/html/NGINX; # From expanded-nginx.conf, was /var/www/html in old
            index Main.html index.html index.htm; # Main.html from expanded
        }

        # Location for HLS playback
        # Access HLS streams at http://YOUR_SERVER_IP_OR_DOMAIN:PORT/hls/...
        # e.g., http://localhost:8080/hls/1/STREAM_NAME/index.m3u8
        # e.g., http://localhost:8080/hls/shorts_1/STREAM_NAME/index.m3u8
        location /hls {
            types {
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            }
            root /mnt; # Root for HLS, matches hls_path directives like /mnt/hls/...
            add_header Cache-Control no-cache;
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';
            add_header 'Access-Control-Allow-Headers' 'Range';
            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' '*' always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
                add_header 'Access-Control-Max-Age' 1728000;
                add_header 'Content-Type' 'text/plain; charset=utf-8';
                add_header 'Content-Length' 0;
                return 204;
            }
        }

        # RTMP Statistics Page (optional, from original example)
        location /stat {
            rtmp_stat all;
            rtmp_stat_stylesheet stat.xsl;
        }
        location = /stat.xsl {
             root /var/www/html; # Assuming stat.xsl is placed here by setup
        }
    }
}
